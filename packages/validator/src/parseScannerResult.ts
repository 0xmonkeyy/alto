import { Address, EntryPointAbi, PaymasterAbi, SenderCreatorAbi, StakeInfo, StorageMap, TestOpcodesAccountAbi, TestOpcodesAccountFactoryAbi, TestStorageAccountAbi, UserOperation, ValidationErrors, ValidationResult } from "@alto/types"
import { requireCond } from "@alto/utils"
import { Abi, decodeErrorResult, decodeFunctionResult, getAbiItem, keccak256, pad } from "viem"
import { BundlerCollectorReturn, ExitInfo } from "./BundleCollectorTracer"

interface CallEntry {
    to: string
    from: string
    type: string // call opcode
    method: string // parsed method, or signash if unparsed
    revert?: any // parsed output from REVERT
    return?: any // parsed method output.
    value?: bigint
  }

/**
 * parse all call operation in the trace.
 * notes:
 * - entries are ordered by the return (so nested call appears before its outer call
 * - last entry is top-level return from "simulateValidation". it as ret and rettype, but no type or address
 * @param tracerResults
 */
function parseCallStack(tracerResults: BundlerCollectorReturn): CallEntry[] {

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const abi = Object.values(
        [
            ...TestOpcodesAccountAbi,
            ...TestOpcodesAccountFactoryAbi,
            ...TestStorageAccountAbi,
            ...SenderCreatorAbi,
            ...EntryPointAbi,
            ...PaymasterAbi
        ].reduce((set, entry) => {
            switch (entry.type) {
                case "error":
                case "function":
                    {
                        const key = `${entry.name}(${entry.inputs.map((i) => i.type).join(",")})`
                        return { ...set, [key]: entry }
                    }
                case "constructor":
                case "event":
                case "fallback":
                case "receive":
                    return set
            }
        }, {})
    ) as Abi

    const out: CallEntry[] = []
    const stack: any[] = []
    for (const c of tracerResults.calls.filter((x) => !x.type.startsWith("depth"))) {
        if (c.type.match(/REVERT|RETURN/) != null) {
            const top = stack.splice(-1)[0] ?? {
                type: "top",
                method: "validateUserOp"
            }
            const returnData: string = (c as ExitInfo).data
            if (top.type.match(/CREATE/) != null) {
                out.push({
                    to: top.to,
                    from: top.from,
                    type: top.type,
                    method: "",
                    return: `len=${returnData.length}`
                })
            } else {
                const method = getAbiItem({ abi, name: top.method }) || top.method
                // const method = callCatch(() =>  xfaces.getFunction(top.method), top.method)
                if (c.type === "REVERT") {
                    const parsedError = decodeErrorResult({ abi, data: returnData as `0x${string}` })
                    out.push({
                        to: top.to,
                        from: top.from,
                        type: top.type,
                        method: method.name,
                        value: top.value,
                        revert: parsedError
                    })
                } else {
                    const ret = decodeFunctionResult({ abi, functionName: method.name, data: returnData as `0x${string}` })
                    out.push({
                        to: top.to,
                        from: top.from,
                        type: top.type,
                        method: method.name ?? method,
                        return: ret
                    })
                }
            }
        } else {
            stack.push(c)
        }
    }

    if (stack.length !== 0) {
        throw Error("stack not empty at the end")
    }

    return out
}

/**
 * slots associated with each entity.
 * keccak( A || ...) is associated with "A"
 * removed rule: keccak( ... || ASSOC ) (for a previously associated hash) is also associated with "A"
 *
 * @param stakeInfoEntities stake info for (factory, account, paymaster). factory and paymaster can be null.
 * @param keccak array of buffers that were given to keccak in the transaction
 */

function parseEntitySlots(
    stakeInfoEntities: { [addr: string]: StakeInfo | undefined },
    keccak: string[]
): { [_addr: string]: Set<string> } {
    // for each entity (sender, factory, paymaster), hold the valid slot addresses
    // valid: the slot was generated by keccak(entity || ...)
    const entitySlots: { [addr: string]: Set<string> } = {}

    keccak.forEach((k) => {
        Object.values(stakeInfoEntities).forEach((info) => {
            // const addr = info?.addr?.toLowerCase()
            // if (addr == null) return
            const addr = info?.addr?.toLowerCase()
            if (addr == null) return
            const addrPadded = pad(addr as Address, { size: 32 })
            if (entitySlots[addr] == null) {
                entitySlots[addr] = new Set<string>()
            }

            const currentEntitySlots = entitySlots[addr]

            // valid slot: the slot was generated by keccak(entityAddr || ...)
            if (k.startsWith(addrPadded.toString())) {
                currentEntitySlots.add(keccak256(k as `0x${string}`))
            }
        })
    })

    return entitySlots
}

/**
 * parse collected simulation traces and revert if they break our rules
 * @param userOp the userOperation that was used in this simulation
 * @param tracerResults the tracer return value
 * @param validationResult output from simulateValidation
 * @param entryPoint the entryPoint that hosted the "simulatedValidation" traced call.
 * @return list of contract addresses referenced by this UserOp
 */

export function parseScannerResult(
    userOp: UserOperation,
    tracerResults: BundlerCollectorReturn,
    validationResult: ValidationResult,
    entryPointAddress: Address
): [string[], StorageMap] {
    // debug("=== simulation result:", inspect(tracerResults, true, 10, true))
    // todo: block access to no-code addresses (might need update to tracer)

    const bannedOpCodes = new Set([
        "GASPRICE",
        "GASLIMIT",
        "DIFFICULTY",
        "TIMESTAMP",
        "BASEFEE",
        "BLOCKHASH",
        "NUMBER",
        "SELFBALANCE",
        "BALANCE",
        "ORIGIN",
        "GAS",
        "CREATE",
        "COINBASE",
        "SELFDESTRUCT",
        "RANDOM",
        "PREVRANDAO"
    ])

    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (Object.values(tracerResults.numberLevels).length < 2) {
        throw new Error("Unexpected traceCall result: no NUMBER opcodes, and not REVERT")
    }

    const callStack = parseCallStack(tracerResults)
    const callInfoEntryPoint = callStack.find(
        (call) =>
            call.to === entryPointAddress &&
            call.from !== entryPointAddress &&
            call.method !== "0x" &&
            call.method !== "depositTo"
    )

    requireCond(
        callInfoEntryPoint == null,
        `illegal call into EntryPoint during validation ${callInfoEntryPoint?.method}`,
        ValidationErrors.OpcodeValidation
    )

    requireCond(
        !callStack.some(
            (call) => call.to?.toLowerCase() !== entryPointAddress.toLowerCase() && (call.value ?? 0) !== 0),
        "May not make CALL with value",
        ValidationErrors.OpcodeValidation
    )

    const sender = userOp.sender.toLowerCase()
    // stake info per "number" level (factory, sender, paymaster)
    // we only use stake info if we notice a memory reference that require stake
    const stakeInfoEntities = {
        factory: validationResult.factoryInfo,
        account: validationResult.senderInfo,
        paymaster: validationResult.paymasterInfo
    }

    const entitySlots: { [addr: string]: Set<string> } = parseEntitySlots(stakeInfoEntities as any, tracerResults.keccak)

    Object.entries(stakeInfoEntities).forEach(([entityTitle, entStakes], index) => {
        const entityAddr = (entStakes as any)?.addr ?? ""
        const currentNumLevel = tracerResults.numberLevels[index]
        const opcodes = currentNumLevel.opcodes
        const access = currentNumLevel.access

        requireCond(
            !(currentNumLevel.oog ?? false),
            `${entityTitle} internally reverts on oog`,
            ValidationErrors.OpcodeValidation
        )
        Object.keys(opcodes).forEach((opcode) =>
            requireCond(
                !bannedOpCodes.has(opcode),
                `${entityTitle} uses banned opcode: ${opcode}`,
                ValidationErrors.OpcodeValidation
            )
        )
        if (entityTitle === "factory") {
            requireCond(
                (opcodes.CREATE2 ?? 0) <= 1,
                `${entityTitle} with too many CREATE2`,
                ValidationErrors.OpcodeValidation
            )
        } else {
            requireCond(
                opcodes.CREATE2 == null,
                `${entityTitle} uses banned opcode: CREATE2`,
                ValidationErrors.OpcodeValidation
            )
        }

        Object.entries(access).forEach(([addr, { reads, writes }]) => {
            // testing read/write access on contract "addr"
            if (addr === sender) {
                // allowed to access sender's storage
                return
            }
            if (addr === entryPointAddress) {
                // ignore storage access on entryPoint (balance/deposit of entities.
                // we block them on method calls: only allowed to deposit, never to read
                return
            }

            // return true if the given slot is associated with the given address, given the known keccak operations:
            // @param slot the SLOAD/SSTORE slot address we're testing
            // @param addr - the address we try to check for association with
            // @param reverseKeccak - a mapping we built for keccak values that contained the address
            function associatedWith(slot: string, addr: string, entitySlots: { [_addr: string]: Set<string> }): boolean {
                const addrPadded = pad(addr as Address, { size: 32 }).toLowerCase()
                if (slot === addrPadded) {
                    return true
                }
                const k = entitySlots[addr]
                if (k == null) {
                    return false
                }
                const slotN = BigInt(slot)
                // scan all slot entries to check of the given slot is within a structure, starting at that offset.
                // assume a maximum size on a (static) structure size.
                for (const k1 of k.keys()) {
                    const kn = BigInt(k1)
                    if (slotN > kn && slotN < (kn + 128n)) {
                        return true
                    }
                }
                return false
            }

            // scan all slots. find a referenced slot
            // at the end of the scan, we will check if the entity has stake, and report that slot if not.
            let requireStakeSlot: string | undefined
            ;[...Object.keys(writes), ...Object.keys(reads)].forEach((slot) => {
                // slot associated with sender is allowed (e.g. token.balanceOf(sender)
                // but during initial UserOp (where there is an initCode), it is allowed only for staked entity
                if (associatedWith(slot, sender, entitySlots)) {
                    if (userOp.initCode.length > 2) {
                        requireStakeSlot = slot
                    }
                } else if (associatedWith(slot, entityAddr, entitySlots)) {
                    // accessing a slot associated with entityAddr (e.g. token.balanceOf(paymaster)
                    requireStakeSlot = slot
                } else if (addr === entityAddr) {
                    // accessing storage member of entity itself requires stake.
                    requireStakeSlot = slot
                } else {
                    // accessing arbitrary storage of another contract is not allowed
                    const readWrite = Object.keys(writes).includes(addr) ? "write to" : "read from"
                    requireCond(
                        false,
                        `${entityTitle} has forbidden ${readWrite} ${nameAddr(addr, entityTitle)} slot ${slot}`,
                        ValidationErrors.OpcodeValidation,
                        { [entityTitle]: (entStakes as any)?.addr }
                    )
                }
            })

            // if addr is current account/paymaster/factory, then return that title
            // otherwise, return addr as-is
            function nameAddr(addr: string, currentEntity: string): string {
                const [title] =
                    Object.entries(stakeInfoEntities).find(
                        ([title, info]) => (info as any)?.addr.toLowerCase() === addr.toLowerCase()
                    ) ?? []

                return title ?? addr
            }

            requireCondAndStake(
                requireStakeSlot != null,
                entStakes as any,
                `unstaked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`
            )
        })

        if (entityTitle === "paymaster") {
            const validatePaymasterUserOp = callStack.find(
                (call) => call.method === "validatePaymasterUserOp" && call.to === entityAddr
            )
            const context = validatePaymasterUserOp?.return?.context
            requireCondAndStake(
                context != null && context !== "0x",
                entStakes as any,
                "unstaked paymaster must not return context"
            )
        }

        // helper method: if condition is true, then entity must be staked.
        function requireCondAndStake(cond: boolean, entStake: StakeInfo | undefined, failureMessage: string): void {
            if (!cond) {
                return
            }
            if (entStakes == null) {
                throw new Error(
                    `internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`
                )
            }
            requireCond(
                1 <= entStakes.stake && 1 <= entStakes.unstakeDelaySec,
                failureMessage,
                ValidationErrors.OpcodeValidation,
                { [entityTitle]: (entStakes as any)?.addr }
            )

            // TODO: check real minimum stake values
        }

        requireCond(
            Object.keys(currentNumLevel.contractSize).find((addr) => currentNumLevel.contractSize[addr] <= 2) == null,
            `${entityTitle} accesses un-deployed contract ${JSON.stringify(currentNumLevel.contractSize)}`,
            ValidationErrors.OpcodeValidation
        )
    })

    // // return list of contract addresses by this UserOp. already known not to contain zero-sized addresses.
    const addresses = tracerResults.numberLevels.flatMap((level) => Object.keys(level.contractSize))
    const storageMap: StorageMap = {}
    tracerResults.numberLevels.forEach((level) => {
        Object.keys(level.access).forEach((addr) => {
            storageMap[addr] = storageMap[addr] ?? level.access[addr].reads
        })
    })
    return [addresses, storageMap]
}

